<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PacMan: Evolution</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background for contrast */
            display: flex;
            justify-content: center;
            align-items: center;6
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000; /* Black background for the game area */
            border-radius: 1rem; /* Rounded corners */
            padding: 1rem;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Glowing effect */
            position: relative; /* For absolute positioning of level select */
        }
        canvas {
            background-color: #000; /* Reverted to Black */
            display: block;
            border-radius: 0.5rem;
            border: 2px solid #00ffff; /* Cyan border for the game board */
            touch-action: none; /* Disable default touch actions */
            max-width: 100%; /* Ensure canvas fits within container */
            height: auto; /* Maintain aspect ratio */
        }
        .game-info {
            color: #fff;
            font-size: 1.25rem;
            margin-top: 1rem;
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 600px;
        }
        .game-status {
            color: #fff;
            font-size: 1.5rem;
            margin-top: 1rem;
            text-align: center;
            min-height: 2rem; /* Reserve space to prevent CLS */
        }
        .level-select-overlay, .pause-menu-overlay {
            position: fixed; /* Changed from absolute to fixed */
            top: 0;
            left: 0;
            right: 0; /* Added to span full width */
            bottom: 0; /* Added to span full height */
            width: 100vw; /* Ensure it covers the whole viewport */
            height: 100vh; /* Ensure it covers the whole viewport */
            background-color: rgba(0, 0, 0, 0.9); /* Semi-transparent black overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10; /* Above the canvas */
            border-radius: 1.5rem; /* This will now apply to the whole fixed overlay */
        }
        .level-select-overlay h2, .pause-menu-overlay h2 {
            color: #fff;
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-shadow: 0 0 10px #00ffff; /* Glowing text */
        }
        /* Main container for all map rows - now acts as a vertical stack */
        .level-select-buttons, .pause-menu-buttons {
            display: flex;
            flex-direction: column; /* Stack map rows vertically */
            gap: 1.5rem; /* Space between map rows */
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5); /* Slightly darker background for the menu area */
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.2);
            width: 90%; /* Max width for the menu container */
            max-width: 800px;
            /* Added explicit height to ensure it takes up available space within the flex container */
            max-height: 80vh; /* Limit height to allow vertical scrolling if many map rows */
            overflow-y: auto; /* Enable vertical scrolling for the whole menu if needed */
        }

        /* Styles for each individual map row (e.g., "Pacman Map 1: [buttons]") */
        .map-row {
            display: flex;
            gap: 1rem;
            overflow-x: auto; /* Enable horizontal scrolling within each row */
            white-space: nowrap; /* Prevent buttons from wrapping within the row */
            justify-content: flex-start; /* Align items to the start */
            padding-bottom: 0.5rem; /* Space for horizontal scrollbar */
            min-height: 4rem; /* Ensure enough vertical space for buttons and scrollbar */
            align-items: center; /* Vertically center buttons in the row */
            border-bottom: 1px solid rgba(0, 255, 255, 0.1); /* Separator between map groups */
            padding-top: 0.5rem;
            width: 100%; /* Ensure map row takes full width of its parent */
        }
        .map-row:last-child {
            border-bottom: none; /* No border on the last row */
        }

        .map-row-title {
            color: #00ffff; /* Cyan for map titles */
            font-size: 1.1rem;
            font-weight: bold;
            flex-shrink: 0; /* Prevent title from shrinking */
            padding-right: 1rem; /* Space between title and buttons */
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        /* Custom scrollbar for Webkit browsers (for both horizontal and vertical) */
        .level-select-buttons::-webkit-scrollbar,
        .map-row::-webkit-scrollbar,
        .pause-menu-buttons::-webkit-scrollbar {
            height: 8px; /* For horizontal */
            width: 8px; /* For vertical */
        }
        .level-select-buttons::-webkit-scrollbar-track,
        .map-row::-webkit-scrollbar-track,
        .pause-menu-buttons::-webkit-scrollbar-track {
            background: #1a202c;
            border-radius: 10px;
        }
        .level-select-buttons::-webkit-scrollbar-thumb,
        .map-row::-webkit-scrollbar-thumb,
        .pause-menu-buttons::-webkit-scrollbar-thumb {
            background-color: #00ffff;
            border-radius: 10px;
            border: 2px solid #1a202c;
        }

        .level-select-buttons button, .pause-menu-buttons button {
            background-color: #00ffff; /* Cyan button */
            color: #1a202c; /* Dark text */
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 255, 255, 0.4);
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }
        .level-select-buttons button:hover, .pause-menu-buttons button:hover {
            background-color: #00e6e6; /* Slightly darker cyan on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 255, 255, 0.6);
        }
        .level-select-buttons button:active, .pause-menu-buttons button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 255, 255, 0.3);
        }
        .version-indicator {
            position: absolute;
            bottom: 0.5rem;
            left: 0.5rem;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            z-index: 11; /* Above other elements */
        }

        /* Debug Menu Specific Styles */
        .debug-menu {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(0, 255, 255, 0.1);
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        .debug-menu h3 {
            color: #00ffff;
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
        }
        .debug-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: #fff;
            font-size: 1.1rem;
            cursor: pointer;
        }
        .debug-option input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
            accent-color: #00ffff; /* Cyan checkbox */
            cursor: pointer;
        }

        /* Build Mode Controls */
        .build-mode-controls {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
            z-index: 20; /* Above everything else */
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }
        .build-mode-controls button {
            background-color: #00ffff;
            color: #1a202c;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 255, 255, 0.3);
        }
        .build-mode-controls button:hover {
            background-color: #00e6e6;
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 255, 255, 0.5);
        }
        .copy-confirmation {
            color: #00ff00; /* Green for success */
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            text-align: center;
        }
        .copy-confirmation.show {
            opacity: 1;
        }
        .build-mode-stats {
            color: #fff;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }
        .pacman-spawn-status.yes {
            color: #FFFF00; /* Yellow */
        }
        .pacman-spawn-status.no {
            color: #FF0000; /* Red */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="level-select-overlay" id="levelSelectOverlay">
            <h2>Select Level</h2>
            <div class="level-select-buttons" id="levelSelectButtons">
                <!-- Level buttons will be generated here by JavaScript -->
                <label class="debug-option">
                    <input type="checkbox" id="buildModeToggle">
                    <span>Enable Build Mode</span>
                </label>
            </div>
        </div>

        <div class="pause-menu-overlay" id="pauseMenuOverlay" style="display: none;">
            <h2>Game Paused</h2>
            <div class="pause-menu-buttons">
                <button id="resumeGameButton">Resume Game</button>
                <button id="returnToStartMenuButton">Return to Start Menu</button>

                <div class="debug-menu">
                    <h3>Debug Options</h3>
                    <label class="debug-option">
                        <input type="checkbox" id="showGhostHouseToggle">
                        <span>Show Ghost House</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="game-info">
            <span>Score: <span id="score">0</span></span>
            <span>Lives: <span id="lives">3</span></span>
            <span>Level: <span id="level">1</span></span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="game-status" id="gameStatus"></div>
        <div class="version-indicator">v1.0.3</div>
    </div>

    <div class="build-mode-controls" id="buildModeControls" style="display: none;">
        <button id="exportMazeJsonButton">Export Maze JSON</button>
        <div id="copyConfirmation" class="copy-confirmation">Copied to clipboard!</div>
        <div class="build-mode-stats">
            <span id="ghostSpawnsCounter">Ghosts Spawns = 0</span>
            <span id="pacmanSpawnCounter">Pac-Man Spawn = No</span>
        </div>
    </div>

    <script>
        // --- Game Configuration ---
        const TILE_SIZE = 30;
        const PACMAN_RADIUS = TILE_SIZE / 2 - 1;
        const GHOST_RADIUS = TILE_SIZE / 2 - 2;
        const DOT_RADIUS = 2;
        const POWER_PELLET_RADIUS = 5;

        // Colors
        const PATH_COLOR = '#000000';
        const GHOST_PATH_COLOR_BUILD_MODE = '#333333';
        const DOT_COLOR = '#FFFFFF';
        const POWER_PELLET_COLOR = '#FFFF00';
        const FRIGHTENED_GHOST_COLOR = '#0000FF';
        const BLINKY_SPAWN_COLOR = '#FFFF00';

        // Wall colors for each level
        const MAZE_WALL_COLORS = [
            '#0000FF', // Level 1: Blue
            '#00FF00'  // Level 2: Green
        ];

        // Ghost colors
        const GHOST_COLORS = {
            'blinky': '#FF0000',
            'pinky': '#FFC0CB',
            'inky': '#00FFFF',
            'clyde': '#FFA500'
        };

        const POWER_PELLET_FLASH_INTERVAL = 200;
        const CURSOR_FLASH_INTERVAL = 200;
        const CURSOR_FEEDBACK_DURATION = 100;

        const BASE_PIXEL_SPEED = 2;

        // Difficulty configurations
        const DIFFICULTY_TIERS = [
            {
                pacmanNormal: 0.8 * BASE_PIXEL_SPEED,
                pacmanFrightened: 0.9 * BASE_PIXEL_SPEED,
                ghostChase: 0.75 * BASE_PIXEL_SPEED,
                ghostFrightened: 0.5 * BASE_PIXEL_SPEED,
                ghostTunnel: 0.4 * BASE_PIXEL_SPEED,
                frightenedDurationMs: 8000
            }
        ];

        // Character configurations
        const CHARACTER_CONFIGS = {
            PACMAN: {
                mouthAnimationFrames: [2, 0],
                chompInterval: 75,
                initialMouthState: 0,
                color: '#FFFF00',
                deathAnimationType: 'disappear'
            }
        };

        const LEVEL_PROGRESSION_DATA = [
            { mazeIndex: 0, characterType: 'PACMAN', difficultyTierIndex: 0, displayName: { game: 'Experimental', mapNumber: 1, iteration: 1 } },
            { mazeIndex: 1, characterType: 'PACMAN', difficultyTierIndex: 0, displayName: { game: 'Experimental', mapNumber: 1, iteration: 2 } }
        ];

        const GHOST_HOUSE_CONFIGS = [
            {
                doorTiles: [{row: 12, col: 13}, {row: 12, col: 14}], 
                blinkyStart: { row: 11, col: 13 }, 
                pinkyStart: { row: 14, col: 13 },  
                inkyStart: { row: 14, col: 12 },   
                clydeStart: { row: 14, col: 14 },    
                exitPoint: { row: 11, col: 13 }, 
                returnPoint: { row: 14, col: 13 } 
            },
            {
                doorTiles: [{row: 12, col: 13}, {row: 12, col: 14}], 
                blinkyStart: { row: 11, col: 13 }, 
                pinkyStart: { row: 14, col: 13 },  
                inkyStart: { row: 14, col: 12 },   
                clydeStart: { row: 14, col: 14 },    
                exitPoint: { row: 11, col: 13 }, 
                returnPoint: { row: 14, col: 13 } 
            }
        ];

        const GHOST_HOUSE_BOUNDING_BOXES = [
            { startRow: 12, endRow: 15, startCol: 10, endCol: 17 },
            { startRow: 12, endRow: 15, startCol: 10, endCol: 17 }
        ];

        // --- Maze Data ---
        const tileSymbols = {
          ' ': 0, '#': 1, '.': 2, 'o': 3, '~': 4, '^': 5, '@': 6, '=': 7
        };
        
        const MAZE_DATA_STRINGS = [
            [
                "############################",
                "#............##............#",
                "#.####.#####.##.#####.####.#",
                "#o####.#####.##.#####.####o#",
                "#.####.#####.##.#####.####.#",
                "#..........................#",
                "#.####.##.########.##.####.#",
                "#.####.##.########.##.####.#",
                "#......##....##....##......#",
                "######.##### ## #####.######",
                "######.##### ## #####.######",
                "######.##~~~ ~~ ~~~##.######",
                "######.##~###==###~##.######",
                "######.##~#~~  ~~#~##.######",
                " ~~~~~.~~~#~~~~~~#~~~.~~~~~ ",
                "######.##~########~##.######",
                "######.## ~~~~~~~~ ##.######",
                "######.## ######## ##.######",
                "######.## ######## ##.######",
                "#............##............#",
                "#.####.#####.##.#####.####.#",
                "#.####.#####.##.#####.####.#",
                "#o..##.......  .......##..o#",
                "###.##.##.########.##.##.###",
                "###.##.##.########.##.##.###",
                "#......##....##....##......#",
                "#.##########.##.##########.#",
                "#.##########.##.##########.#",
                "#............@.............#",
                "############################"
            ],
            [
                "############################",
                "#............##............#",
                "#.####.#####.##.#####.####.#",
                "#o####.#####.##.#####.####o#",
                "#.####.#####.##.#####.####.#",
                "#..........................#",
                "#.####.##.########.##.####.#",
                "#.####.##.########.##.####.#",
                "#......##....##....##......#",
                "######.##### ## #####.######",
                "######.##### ## #####.######",
                "######.##~~~ ~~ ~~~##.######",
                "######.##~###==###~##.######",
                "######.##~#~~  ~~#~##.######",
                " ~~~~~.~~~#~~~~~~#~~~.~~~~~ ",
                "######.##~########~##.######",
                "######.## ~~~~~~~~ ##.######",
                "######.## ######## ##.######",
                "######.## ######## ##.######",
                "#............##............#",
                "#.####.#####.##.#####.####.#",
                "#.####.#####.##.#####.####.#",
                "#o..##.......  .......##..o#",
                "###.##.##.########.##.##.###",
                "###.##.##.########.##.##.###",
                "#......##....##....##......#",
                "#.##########.##.##########.#",
                "#.##########.##.##########.#",
                "#............@.............#",
                "############################"
            ]
        ];

        // --- Game Variables ---
        let canvas, ctx;
        let pacman = { x: 0, y: 0, dx: 0, dy: 0, nextDx: 0, nextDy: 0, mouthState: 0, currentMouthFrameIndex: 0, mouthAnimationFrames: [], chompInterval: 0, color: '', deathAnimationType: '', speedNormal: 0, speedFrightened: 0 };
        let ghosts = [];
        let dotsRemaining;
        let score = 0;
        let lives = 3;
        let level = 0;
        let gameOver = false;
        let gameWin = false;
        let frightenedMode = false;
        let frightenedTimer = 0;
        let mouthAnimationTimer = 0;
        let currentMaze;
        let paused = false;
        let showGhostHouseDebug = false;
        let isBuildModeActive = false;
        let buildCursor = { row: 0, col: 0, flashState: true, flashTimer: 0, feedbackTimer: 0, feedbackActive: false };

        let gameState = 'level_select';
        let readyPromptTimer = 0;
        const READY_PROMPT_DURATION = 2000;

        let powerPelletFlashState = true;
        let powerPelletFlashTimer = 0;

        let animationFrameId = null;
        let lastFrameTime = null;

        const BUILD_TILE_TYPES = [0, 2, 1, 3, 4, 7, 5, 6];


        // --- Utility Functions ---
        function parseMaze(mazeStringArray) {
            return mazeStringArray.map(rowString => 
                rowString.split('').map(char => tileSymbols[char] || 0)
            );
        }

        function getMazeDimensions() {
            if (!currentMaze || !currentMaze.length || !currentMaze[0]) {
                console.error("Error: currentMaze is undefined or malformed when getting dimensions.", currentMaze);
                return { rows: 31, cols: 28 };
            }
            const rows = currentMaze.length;
            const cols = currentMaze[0].length;
            return { rows, cols };
        }

        function getTileCenter(row, col) {
            return {
                x: col * TILE_SIZE + TILE_SIZE / 2,
                y: row * TILE_SIZE + TILE_SIZE / 2
            };
        }

        function copyMazeToClipboard() {
            const mazeJson = JSON.stringify(currentMaze);
            const confirmationDiv = document.getElementById('copyConfirmation');
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = mazeJson;
            tempTextArea.style.position = 'absolute';
            tempTextArea.style.left = '-9999px';
            document.body.appendChild(tempTextArea);
            tempTextArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    confirmationDiv.innerText = 'Copied to clipboard!';
                    confirmationDiv.style.color = '#00ff00';
                } else {
                    confirmationDiv.innerText = 'Failed to copy! Please copy manually.';
                    confirmationDiv.style.color = 'red';
                    console.error('Failed to copy maze JSON using document.execCommand.');
                }
            } catch (err) {
                confirmationDiv.innerText = 'Failed to copy! Please copy manually.';
                confirmationDiv.style.color = 'red';
                console.error('Error attempting to copy maze JSON:', err);
            } finally {
                document.body.removeChild(tempTextArea);
                confirmationDiv.classList.add('show');
                setTimeout(() => {
                    confirmationDiv.classList.remove('show');
                    confirmationDiv.innerText = 'Copied to clipboard!';
                    confirmationDiv.style.color = '#00ff00';
                }, 1500);
            }
        }

        // --- Game Initialization ---
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            currentMaze = parseMaze(MAZE_DATA_STRINGS[0]);

            canvas.style.display = 'none';
            document.querySelector('.game-info').style.display = 'none';
            document.getElementById('gameStatus').style.display = 'none';
            document.getElementById('pauseMenuOverlay').style.display = 'none';
            document.getElementById('buildModeControls').style.display = 'none';

            document.getElementById('levelSelectOverlay').style.display = 'flex';
            generateLevelSelectButtons();

            const { rows, cols } = getMazeDimensions();
            canvas.width = cols * TILE_SIZE;
            canvas.height = rows * TILE_SIZE;

            document.getElementById('resumeGameButton').addEventListener('click', togglePause);
            document.getElementById('returnToStartMenuButton').addEventListener('click', returnToStartMenu);
            document.getElementById('showGhostHouseToggle').addEventListener('change', (e) => {
                showGhostHouseDebug = e.target.checked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawMaze();
                if (gameState === 'build_mode') {
                    drawBuildCursor();
                    updateBuildModeCounters();
                } else {
                    drawPacman();
                    ghosts.forEach(drawGhost);
                }
            });
            document.getElementById('buildModeToggle').addEventListener('change', (e) => {
                isBuildModeActive = e.target.checked;
                if (isBuildModeActive) {
                    gameState = 'build_mode';
                    document.getElementById('buildModeControls').style.display = 'flex';
                    buildCursor.row = 0;
                    buildCursor.col = 0;
                    updateBuildModeCounters();
                } else {
                    returnToStartMenu();
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawMaze();
                if (gameState === 'build_mode') {
                    drawBuildCursor();
                }
            });
            document.getElementById('exportMazeJsonButton').addEventListener('click', copyMazeToClipboard);
        }

        function generateLevelSelectButtons() {
            const buttonContainer = document.getElementById('levelSelectButtons');
            const buildModeToggleContainer = document.getElementById('buildModeToggle').parentNode;
            buttonContainer.innerHTML = '';
            buttonContainer.appendChild(buildModeToggleContainer);

            const groupedLevels = new Map();

            LEVEL_PROGRESSION_DATA.forEach((levelData, index) => {
                const { game, mapNumber } = levelData.displayName;
                if (!groupedLevels.has(game)) {
                    groupedLevels.set(game, new Map());
                }
                const gameMaps = groupedLevels.get(game);
                if (!gameMaps.has(mapNumber)) {
                    gameMaps.set(mapNumber, []);
                }
                gameMaps.get(mapNumber).push({ levelData, index });
            });

            const customGameOrder = ['Pacman', 'Experimental'];
            const sortedGameNames = Array.from(groupedLevels.keys()).sort((a, b) => {
                return customGameOrder.indexOf(a) - customGameOrder.indexOf(b);
            });

            sortedGameNames.forEach(gameName => {
                const gameMaps = groupedLevels.get(gameName);
                const sortedMapNumbers = Array.from(gameMaps.keys()).sort((a, b) => a - b);

                sortedMapNumbers.forEach(mapNumber => {
                    const levelsInMap = gameMaps.get(mapNumber);
                    
                    const mapRowDiv = document.createElement('div');
                    mapRowDiv.classList.add('map-row');

                    const titleSpan = document.createElement('span');
                    titleSpan.classList.add('map-row-title');
                    titleSpan.innerText = `${gameName} Map ${mapNumber}:`;
                    mapRowDiv.appendChild(titleSpan);

                    levelsInMap.sort((a, b) => a.levelData.displayName.iteration - b.levelData.displayName.iteration);

                    levelsInMap.forEach(({ levelData, index }) => {
                        const button = document.createElement('button');
                        const { iteration } = levelData.displayName;
                        button.innerText = `${mapNumber}-${iteration}`;
                        button.onclick = () => startGame(index);
                        mapRowDiv.appendChild(button);
                    });
                    buttonContainer.appendChild(mapRowDiv);
                });
            });
        }

        function startGame(selectedLevelIndex) {
            level = selectedLevelIndex;
            document.getElementById('levelSelectOverlay').style.display = 'none';
            canvas.style.display = 'block';
            document.querySelector('.game-info').style.display = 'flex';
            document.getElementById('gameStatus').style.display = 'block';

            resetLevel();
            
            const { rows, cols } = getMazeDimensions();
            canvas.width = cols * TILE_SIZE;
            canvas.height = rows * TILE_SIZE;

            if (isBuildModeActive) {
                gameState = 'build_mode';
                document.getElementById('buildModeControls').style.display = 'flex';
                buildCursor.row = 0;
                buildCursor.col = 0;
                updateBuildModeCounters();
            } else {
                gameState = 'ready_prompt';
                readyPromptTimer = READY_PROMPT_DURATION;
                document.getElementById('buildModeControls').style.display = 'none';
            }

            lastFrameTime = null; 
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function resetLevel() {
            if (level >= LEVEL_PROGRESSION_DATA.length) {
                gameWin = true;
                document.getElementById('gameStatus').innerText = "YOU WIN! Congratulations!";
                gameState = 'game_win';
                return;
            }

            let currentLevelData = LEVEL_PROGRESSION_DATA[level];
            if (!currentLevelData) {
                console.error(`Error: Level progression data for level ${level} is undefined!`);
                level = 0;
                currentLevelData = LEVEL_PROGRESSION_DATA[0];
                if (!currentLevelData) {
                    console.error("Critical Error: LEVEL_PROGRESSION_DATA[0] is also undefined.");
                    document.getElementById('gameStatus').innerText = "CRITICAL ERROR: Game data missing!";
                    gameOver = true;
                    gameState = 'game_over';
                    return; 
                }
            }

            const targetMazeIndex = currentLevelData.mazeIndex;
            const mazeDataToLoad = MAZE_DATA_STRINGS[targetMazeIndex];

            if (mazeDataToLoad === undefined) {
                console.error(`Critical Error: MAZE_DATA_STRINGS[${targetMazeIndex}] is undefined!`);
                document.getElementById('gameStatus').innerText = "ERROR: Maze data missing!";
                gameOver = true;
                gameState = 'game_over';
                return;
            }

            currentMaze = parseMaze(mazeDataToLoad);
            
            dotsRemaining = 0;
            ghosts = [];

            const currentCharacterConfig = CHARACTER_CONFIGS[currentLevelData.characterType];
            const currentDifficultyTier = DIFFICULTY_TIERS[currentLevelData.difficultyTierIndex];
            const currentGhostHouseConfig = GHOST_HOUSE_CONFIGS[currentLevelData.mazeIndex];

            for (let r = 0; r < currentMaze.length; r++) {
                for (let c = 0; c < currentMaze[r].length; c++) {
                    const tile = currentMaze[r][c];
                    if (tile === 2) {
                        dotsRemaining++;
                    } else if (tile === 3) {
                        dotsRemaining++; 
                    } else if (tile === 6) {
                        pacman.x = c * TILE_SIZE + TILE_SIZE / 2;
                        pacman.y = r * TILE_SIZE + TILE_SIZE / 2;
                        pacman.dx = 0;
                        pacman.dy = 0;
                        pacman.nextDx = 0;
                        pacman.nextDy = 0;
                        pacman.mouthState = currentCharacterConfig.initialMouthState;
                        pacman.currentMouthFrameIndex = 0; 
                        pacman.mouthAnimationFrames = currentCharacterConfig.mouthAnimationFrames;
                        pacman.chompInterval = currentCharacterConfig.chompInterval;
                        pacman.color = currentCharacterConfig.color;
                        pacman.deathAnimationType = currentCharacterConfig.deathAnimationType;
                        pacman.speedNormal = currentDifficultyTier.pacmanNormal;
                        pacman.speedFrightened = currentDifficultyTier.pacmanFrightened;
                        currentMaze[r][c] = 0;
                    }
                }
            }

            const ghostNames = ['blinky', 'pinky', 'inky', 'clyde'];
            ghosts = [];
            for (const name of ghostNames) {
                const startPos = currentGhostHouseConfig[`${name}Start`];
                if (startPos) {
                    const newGhost = { 
                        name: name,
                        x: startPos.col * TILE_SIZE + TILE_SIZE / 2,
                        y: startPos.row * TILE_SIZE + TILE_SIZE / 2,
                        dx: 0,
                        dy: 0,
                        frightened: false,
                        eaten: false,
                        state: (name === 'blinky') ? 'active' : 'inHouse', 
                        speedChase: currentDifficultyTier.ghostChase,
                        speedFrightened: currentDifficultyTier.ghostFrightened,
                        speedTunnel: currentDifficultyTier.ghostTunnel 
                    };
                    if (name === 'blinky') {
                        newGhost.dx = -1; 
                    }
                    ghosts.push(newGhost);
                }
            }

            frightenedMode = false;
            frightenedTimer = 0; 
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('lives').innerText = lives;
            document.getElementById('level').innerText = level + 1;
            if (gameOver) {
                document.getElementById('gameStatus').innerText = "GAME OVER!";
            } else if (gameWin) {
                document.getElementById('gameStatus').innerText = "YOU WIN! Congratulations!";
            } else {
                document.getElementById('gameStatus').innerText = "";
            }
        }

        // --- Drawing Functions ---
/**
 * Draws the maze walls on the canvas with a hollow, rounded, contiguous style.
 * This function implements the required two-phase drawing process.
 *
 * It relies on access to the following global variables:
 * - ctx: The 2D canvas rendering context.
 * - currentMaze: A 2D array where `1` represents a wall and any other value is an open path.
 * - TILE_SIZE: The pixel dimension (width and height) of a single maze tile.
 * - wallColor: The CSS color string to use for the walls.
 */
function drawMaze() {
    /**
     * Helper function to check if a tile at given coordinates is a wall.
     * Treats any coordinates outside the maze boundaries as non-walls (open space).
     * @param {number} r - The row index.
     * @param {number} c - The column index.
     * @returns {boolean} - True if the tile is a wall, false otherwise.
     */
    const isWall = (r, c) => {
        return r >= 0 && r < currentMaze.length &&
               c >= 0 && c < currentMaze[0].length &&
               currentMaze[r][c] === 1;
    };

    const inset = TILE_SIZE * 0.25;
    const radius = inset; // The radius for rounded corners is the same as the inset.

    // =========================================================================
    // ## Phase 1: Draw Solid, Inset Wall Segments
    // This phase creates the base shape of the walls. It draws a solid rectangle
    // for each wall tile, but "retreats" any edge that borders an open path.
    // This technique merges adjacent wall tiles into a single, blocky shape.
    // =========================================================================
    ctx.fillStyle = wallColor;
    ctx.beginPath(); // Using a single path for all rectangles is more performant.

    for (let r = 0; r < currentMaze.length; r++) {
        for (let c = 0; c < currentMaze[0].length; c++) {
            if (!isWall(r, c)) {
                continue; // Skip any tile that isn't a wall.
            }

            // Start with the tile's full dimensions.
            let x = c * TILE_SIZE;
            let y = r * TILE_SIZE;
            let w = TILE_SIZE;
            let h = TILE_SIZE;

            // Adjust dimensions based on neighbors. If a side borders open space,
            // it gets inset.
            if (!isWall(r - 1, c)) { // Border with open space above.
                y += inset;
                h -= inset;
            }
            if (!isWall(r + 1, c)) { // Border with open space below.
                h -= inset;
            }
            if (!isWall(r, c - 1)) { // Border with open space to the left.
                x += inset;
                w -= inset;
            }
            if (!isWall(r, c + 1)) { // Border with open space to the right.
                w -= inset;
            }

            // Add the calculated rectangle to the path.
            ctx.rect(x, y, w, h);
        }
    }
    ctx.fill(); // Draw all collected rectangles in a single operation.

    // =========================================================================
    // ## Phase 2: Carve and Add Rounded Corners
    // This phase iterates again to smooth the blocky shape from Phase 1. It adds
    // filled circles to create rounded outer corners and uses the background
    // color to "carve out" rounded inner corners.
    // =========================================================================

    // ### Part A: Add Rounded Outer Corners
    ctx.fillStyle = wallColor;
    for (let r = 0; r < currentMaze.length; r++) {
        for (let c = 0; c < currentMaze[0].length; c++) {
            if (!isWall(r, c)) {
                continue;
            }

            // An outer corner exists where a wall tile has two adjacent non-wall neighbors.
            // We draw a circle in the wall color to round these corners.

            // Top-left outer corner
            if (!isWall(r - 1, c) && !isWall(r, c - 1)) {
                ctx.beginPath();
                ctx.arc(c * TILE_SIZE + inset, r * TILE_SIZE + inset, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            // Top-right outer corner
            if (!isWall(r - 1, c) && !isWall(r, c + 1)) {
                ctx.beginPath();
                ctx.arc(c * TILE_SIZE + TILE_SIZE - inset, r * TILE_SIZE + inset, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            // Bottom-left outer corner
            if (!isWall(r + 1, c) && !isWall(r, c - 1)) {
                ctx.beginPath();
                ctx.arc(c * TILE_SIZE + inset, r * TILE_SIZE + TILE_SIZE - inset, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            // Bottom-right outer corner
            if (!isWall(r + 1, c) && !isWall(r, c + 1)) {
                ctx.beginPath();
                ctx.arc(c * TILE_SIZE + TILE_SIZE - inset, r * TILE_SIZE + TILE_SIZE - inset, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }

    // ### Part B: Carve Out Rounded Inner Corners
    ctx.fillStyle = '#000000'; // Use black (or background color) to "erase".
    
    // An inner corner occurs at an intersection surrounded by three walls and one open path.
    // We check each 2x2 block of tiles to find these locations.
    for (let r = 0; r < currentMaze.length - 1; r++) {
        for (let c = 0; c < currentMaze[0].length - 1; c++) {
            const wall_NW = isWall(r, c);
            const wall_NE = isWall(r, c + 1);
            const wall_SW = isWall(r + 1, c);
            const wall_SE = isWall(r + 1, c + 1);

            const wallCount = wall_NW + wall_NE + wall_SW + wall_SE;

            if (wallCount === 3) {
                // This is an inner corner. Find the center for the carving circle.
                const cornerX = (c + 1) * TILE_SIZE;
                const cornerY = (r + 1) * TILE_SIZE;
                let carveX, carveY;

                // The carving circle's center depends on which of the four tiles is the open one.
                if (!wall_NW) { // Inner corner points toward the Top-Left
                    carveX = cornerX - inset;
                    carveY = cornerY - inset;
                } else if (!wall_NE) { // Inner corner points toward the Top-Right
                    carveX = cornerX + inset;
                    carveY = cornerY - inset;
                } else if (!wall_SW) { // Inner corner points toward the Bottom-Left
                    carveX = cornerX - inset;
                    carveY = cornerY + inset;
                } else { // !wall_SE, inner corner points toward the Bottom-Right
                    carveX = cornerX + inset;
                    carveY = cornerY + inset;
                }
                
                // Draw the carving circle.
                ctx.beginPath();
                ctx.arc(carveX, carveY, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }
}

            // Diagnostic square
            ctx.fillStyle = 'purple';
            ctx.fillRect(0, 0, 10, 10); 


            if (showGhostHouseDebug) {
                const currentMazeIndex = LEVEL_PROGRESSION_DATA[level].mazeIndex;
                const boundingBox = GHOST_HOUSE_BOUNDING_BOXES[currentMazeIndex];
                const ghostConfig = GHOST_HOUSE_CONFIGS[currentMazeIndex];

                if (boundingBox) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3; 
                    const startX = boundingBox.startCol * TILE_SIZE;
                    const startY = boundingBox.startRow * TILE_SIZE;
                    const width = (boundingBox.endCol - boundingBox.startCol + 1) * TILE_SIZE;
                    const height = (boundingBox.endRow - boundingBox.startRow + 1) * TILE_SIZE;
                    ctx.strokeRect(startX, startY, width, height);
                }

                if (ghostConfig && ghostConfig.blinkyStart) {
                    const blinkyX = ghostConfig.blinkyStart.col * TILE_SIZE;
                    const blinkyY = ghostConfig.blinkyStart.row * TILE_SIZE;
                    ctx.strokeStyle = BLINKY_SPAWN_COLOR;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(blinkyX, blinkyY, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        function drawPacman() {
            ctx.save(); 

            ctx.fillStyle = pacman.color;
            ctx.beginPath();

            const angle = Math.atan2(pacman.dy, pacman.dx); 
            const mouthHalfAngle = (pacman.mouthState * 15) * (Math.PI / 180); 
            const startAngle = angle + mouthHalfAngle;
            const endAngle = angle + (Math.PI * 2 - mouthHalfAngle);

            ctx.arc(pacman.x, pacman.y, PACMAN_RADIUS, startAngle, endAngle);
            ctx.lineTo(pacman.x, pacman.y); 
            ctx.closePath();
            ctx.fill();

            ctx.restore(); 
        }

        function drawGhost(ghost) {
            ctx.save(); 

            let ghostColor = GHOST_COLORS[ghost.name];
            if (ghost.eaten) {
                ghostColor = '#FFFFFF'; 
            } else if (ghost.frightened) {
                const currentLevelData = LEVEL_PROGRESSION_DATA[level];
                const currentDifficultyTier = DIFFICULTY_TIERS[currentLevelData.difficultyTierIndex];
                const flashThreshold = currentDifficultyTier.frightenedDurationMs / 4; 
                if (frightenedTimer <= flashThreshold && Math.floor(frightenedTimer / 100) % 2 === 0) {
                    ghostColor = '#FFFFFF';
                } else {
                    ghostColor = FRIGHTENED_GHOST_COLOR;
                }
            }
            ctx.fillStyle = ghostColor;

            ctx.beginPath();
            ctx.arc(ghost.x, ghost.y, GHOST_RADIUS, Math.PI, 0, false); 
            ctx.lineTo(ghost.x + GHOST_RADIUS, ghost.y + GHOST_RADIUS); 
            
            const numLegs = 3;
            const legWidth = (GHOST_RADIUS * 2) / numLegs;
            for (let i = 0; i < numLegs; i++) {
                const startX = ghost.x - GHOST_RADIUS + i * legWidth;
                const endX = startX + legWidth;
                ctx.lineTo(endX, ghost.y + GHOST_RADIUS + (i % 2 === 0 ? 0 : 3)); 
            }
            ctx.lineTo(ghost.x - GHOST_RADIUS, ghost.y + GHOST_RADIUS); 
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#FFFFFF'; 
            ctx.beginPath();
            ctx.arc(ghost.x - GHOST_RADIUS / 2.5, ghost.y - GHOST_RADIUS / 3, GHOST_RADIUS / 3, 0, Math.PI * 2); 
            ctx.arc(ghost.x + GHOST_RADIUS / 2.5, ghost.y - GHOST_RADIUS / 3, GHOST_RADIUS / 3, 0, Math.PI * 2); 
            ctx.fill();

            ctx.fillStyle = '#0000FF'; 
            ctx.beginPath();
            let pupilOffsetX = 0;
            let pupilOffsetY = 0;
            if (!ghost.eaten && !ghost.frightened) {
                if (ghost.dx > 0) pupilOffsetX = GHOST_RADIUS / 6;
                else if (ghost.dx < 0) pupilOffsetX = -GHOST_RADIUS / 6;
                if (ghost.dy > 0) pupilOffsetY = GHOST_RADIUS / 6;
                else if (ghost.dy < 0) pupilOffsetY = -GHOST_RADIUS / 6;
            }
            ctx.arc(ghost.x - GHOST_RADIUS / 2.5 + pupilOffsetX, ghost.y - GHOST_RADIUS / 3 + pupilOffsetY, GHOST_RADIUS / 6, 0, Math.PI * 2); 
            ctx.arc(ghost.x + GHOST_RADIUS / 2.5 + pupilOffsetX, ghost.y - GHOST_RADIUS / 3 + pupilOffsetY, GHOST_RADIUS / 6, 0, Math.PI * 2); 
            ctx.fill();

            ctx.restore(); 
        }

        function drawBuildCursor() {
            if (!buildCursor.feedbackActive) {
                if (buildCursor.flashState) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(buildCursor.col * TILE_SIZE, buildCursor.row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            } else {
                ctx.strokeStyle = 'lime'; 
                ctx.lineWidth = 3; 
                ctx.strokeRect(buildCursor.col * TILE_SIZE, buildCursor.row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }

        function updateBuildModeCounters() {
            let ghostSpawnCount = 0;
            let pacmanSpawnPresent = false;

            for (let r = 0; r < currentMaze.length; r++) {
                for (let c = 0; c < currentMaze[r].length; c++) {
                    if (currentMaze[r][c] === 5) {
                        ghostSpawnCount++;
                    } else if (currentMaze[r][c] === 6) {
                        pacmanSpawnPresent = true;
                    }
                }
            }

            document.getElementById('ghostSpawnsCounter').innerText = `Ghosts Spawns = ${ghostSpawnCount}`;
            const pacmanCounterDiv = document.getElementById('pacmanSpawnCounter');
            pacmanCounterDiv.innerText = `Pac-Man Spawn = ${pacmanSpawnPresent ? 'Yes' : 'No'}`;
            pacmanCounterDiv.classList.toggle('yes', pacmanSpawnPresent);
            pacmanCounterDiv.classList.toggle('no', !pacmanSpawnPresent);
        }

        // --- Game Logic ---
        function getTileAtPixel(x, y) {
            const col = Math.floor(x / TILE_SIZE);
            const row = Math.floor(y / TILE_SIZE);
            if (row >= 0 && row < currentMaze.length && col >= 0 && col < currentMaze[0].length) {
                return { row, col, value: currentMaze[row][col] };
            }
            return null;
        }

        function checkWallCollision(x, y, dx, dy, radius) {
            const nextX = x + dx;
            const nextY = y + dy;

            const corners = [
                { x: nextX - radius, y: nextY - radius },
                { x: nextX + radius, y: nextY - radius },
                { x: nextX - radius, y: nextY + radius },
                { x: nextX + radius, y: nextY + radius }
            ];

            for (const corner of corners) {
                const tile = getTileAtPixel(corner.x, corner.y);
                if (tile && tile.value === 1) { 
                    return true;
                }
            }
            return false;
        }

        function movePacman() {
            const pacmanSpeed = frightenedMode ? pacman.speedFrightened : pacman.speedNormal;

            if (pacman.nextDx !== 0 || pacman.nextDy !== 0) {
                if (!checkWallCollision(pacman.x, pacman.y, pacman.nextDx * pacmanSpeed, pacman.nextDy * pacmanSpeed, PACMAN_RADIUS)) {
                    pacman.dx = pacman.nextDx;
                    pacman.dy = pacman.nextDy;
                    pacman.nextDx = 0; 
                    pacman.nextDy = 0;
                }
            }

            const newX = pacman.x + pacman.dx * pacmanSpeed;
            const newY = pacman.y + pacman.dy * pacmanSpeed;

            if (checkWallCollision(pacman.x, pacman.y, pacman.dx * pacmanSpeed, pacman.dy * pacmanSpeed, PACMAN_RADIUS)) {
                pacman.dx = 0;
                pacman.dy = 0;
            } else {
                pacman.x = newX;
                pacman.y = newY;
            }

            const mazeCols = getMazeDimensions().cols; 
            if (pacman.x < TILE_SIZE / 2 && pacman.dx < 0) { 
                pacman.x = (mazeCols - 0.5) * TILE_SIZE; 
            } else if (pacman.x > canvas.width - TILE_SIZE / 2 && pacman.dx > 0) { 
                pacman.x = 0.5 * TILE_SIZE; 
            }
        }

        function eatDots() {
            const { row, col, value } = getTileAtPixel(pacman.x, pacman.y);
            if (value === 2) {
                currentMaze[row][col] = 0; 
                score += 10;
                dotsRemaining--;
            } else if (value === 3) {
                currentMaze[row][col] = 0; 
                score += 50;
                dotsRemaining--;
                activateFrightenedMode();
            }

            if (dotsRemaining === 0) {
                level++;
                if (level < LEVEL_PROGRESSION_DATA.length) {
                    resetLevel(); 
                    gameState = 'ready_prompt'; 
                    readyPromptTimer = READY_PROMPT_DURATION;
                    lastFrameTime = null; 
                } else {
                    gameWin = true;
                    gameState = 'game_win'; 
                }
            }
        }

        function activateFrightenedMode() {
            frightenedMode = true;
            const currentLevelData = LEVEL_PROGRESSION_DATA[level];
            const currentDifficultyTier = DIFFICULTY_TIERS[currentLevelData.difficultyTierIndex];
            frightenedTimer = currentDifficultyTier.frightenedDurationMs;

            ghosts.forEach(ghost => {
                if (!ghost.eaten) {
                    ghost.frightened = true;
                    ghost.dx *= -1;
                    ghost.dy *= -1;
                }
            });
        }

        function moveGhosts() {
            const currentGhostHouseConfig = GHOST_HOUSE_CONFIGS[LEVEL_PROGRESSION_DATA[level].mazeIndex];

            ghosts.forEach(ghost => {
                if (typeof ghost.x !== 'number' || isNaN(ghost.x)) {
                    console.error(`Ghost ${ghost.name} has invalid x: ${ghost.x}. Resetting.`);
                    const startPos = currentGhostHouseConfig[`${ghost.name}Start`];
                    ghost.x = startPos.col * TILE_SIZE + TILE_SIZE / 2;
                }
                if (typeof ghost.y !== 'number' || isNaN(ghost.y)) {
                    console.error(`Ghost ${ghost.name} has invalid y: ${ghost.y}. Resetting.`);
                    const startPos = currentGhostHouseConfig[`${ghost.name}Start`];
                    ghost.y = startPos.row * TILE_SIZE + TILE_SIZE / 2;
                }

                let currentGhostSpeed; 
                const currentTile = getTileAtPixel(ghost.x, ghost.y);

                if (ghost.eaten) {
                    currentGhostSpeed = ghost.speedChase * 1.5; 
                    const targetX = currentGhostHouseConfig.returnPoint.col * TILE_SIZE + TILE_SIZE / 2;
                    const targetY = currentGhostHouseConfig.returnPoint.row * TILE_SIZE + TILE_SIZE / 2;
                    
                    const distanceToReturnPoint = Math.sqrt(Math.pow(targetX - ghost.x, 2) + Math.pow(targetY - ghost.y, 2));
                    
                    if (distanceToReturnPoint < currentGhostSpeed) {
                        ghost.x = targetX;
                        ghost.y = targetY;
                        ghost.eaten = false; 
                        ghost.frightened = false;
                        ghost.state = 'inHouse'; 
                        ghost.dx = 0;
                        ghost.dy = 0;
                        return; 
                    } else {
                        const angle = Math.atan2(targetY - ghost.y, targetX - ghost.x);
                        ghost.dx = Math.cos(angle);
                        ghost.dy = Math.sin(angle);
                    }
                } else { 
                    if (ghost.state === 'inHouse') {
                        currentGhostSpeed = ghost.speedTunnel;
                        const targetX = currentGhostHouseConfig.exitPoint.col * TILE_SIZE + TILE_SIZE / 2;
                        const targetY = currentGhostHouseConfig.exitPoint.row * TILE_SIZE + TILE_SIZE / 2;
                        const distanceToExit = Math.sqrt(Math.pow(targetX - ghost.x, 2) + Math.pow(targetY - ghost.y, 2));

                        if (distanceToExit < currentGhostSpeed) {
                            ghost.x = targetX;
                            ghost.y = targetY;
                            ghost.state = 'exiting'; 
                        } else {
                            const angle = Math.atan2(targetY - ghost.y, targetX - ghost.x);
                            ghost.dx = Math.cos(angle);
                            ghost.dy = Math.sin(angle);
                        }
                    } else if (ghost.state === 'exiting') {
                        currentGhostSpeed = ghost.speedTunnel;
                        const doorTile = currentGhostHouseConfig.doorTiles[0]; 
                        const exitPathTargetRow = doorTile.row - 1; 
                        const exitPathTargetCol = doorTile.col;
                        const targetX = exitPathTargetCol * TILE_SIZE + TILE_SIZE / 2;
                        const targetY = exitPathTargetRow * TILE_SIZE + TILE_SIZE / 2;

                        const distanceToDoorExit = Math.sqrt(Math.pow(targetX - ghost.x, 2) + Math.pow(targetY - ghost.y, 2));
                        
                        if (distanceToDoorExit < currentGhostSpeed) {
                            ghost.x = targetX;
                            ghost.y = targetY;
                            ghost.dx = 0;
                            ghost.dy = 0;
                            ghost.state = 'active';
                        } else {
                            const angle = Math.atan2(targetY - ghost.y, targetX - ghost.x);
                            ghost.dx = Math.cos(angle);
                            ghost.dy = Math.sin(angle);
                        }
                    } else { 
                        if (ghost.frightened) {
                            currentGhostSpeed = ghost.speedFrightened;
                        } else {
                            const isGhostInTunnel = (currentTile && (currentTile.row === 9 || currentTile.row === 13) && (currentTile.col < 6 || currentTile.col > getMazeDimensions().cols - 7));
                            if (isGhostInTunnel) {
                                currentGhostSpeed = ghost.speedTunnel;
                            } else {
                                currentGhostSpeed = ghost.speedChase;
                            }
                        }
                        const isCurrentDirectionBlocked = checkWallCollision(ghost.x, ghost.y, ghost.dx * currentGhostSpeed, ghost.dy * currentGhostSpeed, GHOST_RADIUS);
                        const atIntersection = Math.abs(ghost.x - getTileCenter(currentTile.row, currentTile.col).x) < 2 && Math.abs(ghost.y - getTileCenter(currentTile.row, currentTile.col).y) < 2;

                        if (isCurrentDirectionBlocked || atIntersection) {
                            let possibleMoves = [];
                            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}]; 

                            for (const dir of directions) {
                                const nextTile = getTileAtPixel(ghost.x + dir.dx * TILE_SIZE, ghost.y + dir.dy * TILE_SIZE);

                                if (nextTile && nextTile.value === 7 && ghost.state === 'active') {
                                    continue;
                                }

                                if (!checkWallCollision(ghost.x, ghost.y, dir.dx * currentGhostSpeed, dir.dy * currentGhostSpeed, GHOST_RADIUS)) {
                                    possibleMoves.push(dir);
                                }
                            }

                            if (possibleMoves.length > 1) {
                                possibleMoves = possibleMoves.filter(move => move.dx !== -ghost.dx || move.dy !== -ghost.dy);
                            }
                            
                            if (possibleMoves.length > 0) {
                                if (ghost.frightened) {
                                    const chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                                    ghost.dx = chosenMove.dx;
                                    ghost.dy = chosenMove.dy;
                                } else { 
                                    const targetX = pacman.x;
                                    const targetY = pacman.y;
                                    let bestMove = possibleMoves[0];
                                    let minDistance = Infinity;

                                    for (const move of possibleMoves) {
                                        const nextGhostX = ghost.x + move.dx * currentGhostSpeed;
                                        const nextGhostY = ghost.y + move.dy * currentGhostSpeed;
                                        const distance = Math.sqrt(Math.pow(targetX - nextGhostX, 2) + Math.pow(targetY - nextGhostY, 2)); 
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            bestMove = move;
                                        }
                                    }
                                    ghost.dx = bestMove.dx;
                                    ghost.dy = bestMove.dy;
                                }
                            }
                        }
                    }
                }

                ghost.x += ghost.dx * currentGhostSpeed;
                ghost.y += ghost.dy * currentGhostSpeed;

                const mazeCols = getMazeDimensions().cols;
                if (ghost.x < TILE_SIZE / 2 && ghost.dx < 0) {
                    ghost.x = (mazeCols - 0.5) * TILE_SIZE; 
                } else if (ghost.x > canvas.width - TILE_SIZE / 2 && ghost.dx > 0) {
                    ghost.x = 0.5 * TILE_SIZE; 
                }
            });
        }

        function checkGhostCollisions() {
            ghosts.forEach(ghost => {
                const distance = Math.sqrt(
                    Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2)
                );

                if (distance < PACMAN_RADIUS + GHOST_RADIUS) {
                    if (ghost.frightened && !ghost.eaten) {
                        ghost.eaten = true;
                        score += 200; 
                        ghost.frightened = false; 
                    } else if (!ghost.eaten) {
                        lives--;
                        if (lives <= 0) {
                            gameOver = true;
                            gameState = 'game_over'; 
                        }
                        resetPositions(); 
                        updateUI();
                    }
                }
            });
        }

        function resetPositions() {
            const currentLevelData = LEVEL_PROGRESSION_DATA[level];
            const currentCharacterConfig = CHARACTER_CONFIGS[currentLevelData.characterType];
            const currentDifficultyTier = DIFFICULTY_TIERS[currentLevelData.difficultyTierIndex];
            const currentGhostHouseConfig = GHOST_HOUSE_CONFIGS[currentLevelData.mazeIndex];

            const mazeStringArray = MAZE_DATA_STRINGS[currentLevelData.mazeIndex];
            for (let r = 0; r < mazeStringArray.length; r++) {
                const c = mazeStringArray[r].indexOf('@');
                if (c !== -1) {
                    pacman.x = c * TILE_SIZE + TILE_SIZE / 2;
                    pacman.y = r * TILE_SIZE + TILE_SIZE / 2;
                    pacman.dx = 0;
                    pacman.dy = 0;
                    pacman.nextDx = 0;
                    pacman.nextDy = 0;
                    pacman.mouthState = currentCharacterConfig.initialMouthState;
                    pacman.currentMouthFrameIndex = 0;
                    pacman.mouthAnimationFrames = currentCharacterConfig.mouthAnimationFrames;
                    pacman.chompInterval = currentCharacterConfig.chompInterval;
                    pacman.color = currentCharacterConfig.color;
                    pacman.deathAnimationType = currentCharacterConfig.deathAnimationType;
                    pacman.speedNormal = currentDifficultyTier.pacmanNormal;
                    pacman.speedFrightened = currentDifficultyTier.pacmanFrightened;
                    break;
                }
            }

            ghosts.forEach(ghost => {
                const startPos = currentGhostHouseConfig[`${ghost.name}Start`];
                ghost.x = startPos.col * TILE_SIZE + TILE_SIZE / 2;
                ghost.y = startPos.row * TILE_SIZE + TILE_SIZE / 2;
                ghost.dx = 0;
                ghost.dy = 0;
                ghost.frightened = false;
                ghost.eaten = false;
                ghost.state = (ghost.name === 'blinky') ? 'active' : 'inHouse'; 
                if (ghost.name === 'blinky') {
                    ghost.dx = -1;
                    ghost.dy = 0;
                }
                ghost.speedChase = currentDifficultyTier.ghostChase;
                ghost.speedFrightened = currentDifficultyTier.ghostFrightened;
                ghost.speedTunnel = currentDifficultyTier.ghostTunnel;
            });
            frightenedMode = false;
            frightenedTimer = 0;
            lastFrameTime = null; 
        }

        // --- Pause Menu Functions ---
        function togglePause() {
            if (gameState === 'playing' || gameState === 'ready_prompt') {
                paused = !paused;
                if (paused) {
                    showPauseMenu();
                } else {
                    hidePauseMenu();
                    lastFrameTime = null; 
                    if (gameState === 'ready_prompt') {
                        readyPromptTimer = READY_PROMPT_DURATION;
                    }
                    if (!animationFrameId) { 
                        animationFrameId = requestAnimationFrame(gameLoop);
                    }
                }
            }
        }

        function showPauseMenu() {
            document.getElementById('pauseMenuOverlay').style.display = 'flex';
            document.getElementById('showGhostHouseToggle').checked = showGhostHouseDebug;
        }

        function hidePauseMenu() {
            document.getElementById('pauseMenuOverlay').style.display = 'none';
        }

        function returnToStartMenu() {
            paused = false; 
            hidePauseMenu(); 

            canvas.style.display = 'none';
            document.querySelector('.game-info').style.display = 'none';
            document.getElementById('gameStatus').style.display = 'none';
            document.getElementById('buildModeControls').style.display = 'none'; 

            document.getElementById('levelSelectOverlay').style.display = 'flex';

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            score = 0;
            lives = 3;
            level = 0;
            gameOver = false;
            gameWin = false;
            frightenedMode = false;
            frightenedTimer = 0;
            mouthAnimationTimer = 0;
            powerPelletFlashTimer = 0;
            powerPelletFlashState = true;
            lastFrameTime = null; 
            showGhostHouseDebug = false; 
            document.getElementById('showGhostHouseToggle').checked = false; 
            isBuildModeActive = false; 
            document.getElementById('buildModeToggle').checked = false; 

            gameState = 'level_select';
        }


        // --- Game Loop ---
        function gameLoop(timestamp) {
            if (lastFrameTime === null) {
                lastFrameTime = timestamp;
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            
            const deltaTime = timestamp - lastFrameTime; 
            lastFrameTime = timestamp; 

            if (gameState === 'level_select') {
                animationFrameId = requestAnimationFrame(gameLoop);
                return; 
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawMaze();
            updateUI(); 

            if (gameState === 'build_mode') {
                buildCursor.flashTimer += deltaTime;
                if (buildCursor.flashTimer >= CURSOR_FLASH_INTERVAL) {
                    buildCursor.flashState = !buildCursor.flashState;
                    buildCursor.flashTimer = 0;
                }
                if (buildCursor.feedbackActive) {
                    buildCursor.feedbackTimer += deltaTime;
                    if (buildCursor.feedbackTimer >= CURSOR_FEEDBACK_DURATION) {
                        buildCursor.feedbackActive = false;
                        buildCursor.feedbackTimer = 0;
                    }
                }
                drawBuildCursor();
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            if (paused) {
                showPauseMenu(); 
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            if (gameState === 'ready_prompt') {
                readyPromptTimer -= deltaTime;

                ctx.fillStyle = 'white';
                ctx.font = `${TILE_SIZE * 1.5}px 'Inter', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("READY!", canvas.width / 2, canvas.height / 2);

                if (readyPromptTimer <= 0) {
                    gameState = 'playing';
                }
                animationFrameId = requestAnimationFrame(gameLoop); 
                return;
            }

            if (gameState === 'game_over' || gameState === 'game_win') {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                return;
            }

            if (gameState === 'playing') {
                movePacman();
                eatDots();
                moveGhosts();
                checkGhostCollisions();

                if (pacman.dx !== 0 || pacman.dy !== 0) {
                    mouthAnimationTimer += deltaTime;
                    if (mouthAnimationTimer >= pacman.chompInterval) { 
                        pacman.currentMouthFrameIndex = (pacman.currentMouthFrameIndex + 1) % pacman.mouthAnimationFrames.length;
                        pacman.mouthState = pacman.mouthAnimationFrames[pacman.currentMouthFrameIndex];
                        mouthAnimationTimer = 0;
                    }
                } else {
                    pacman.mouthState = pacman.mouthAnimationFrames[0]; 
                    pacman.currentMouthFrameIndex = 0;
                    mouthAnimationTimer = 0;
                }

                powerPelletFlashTimer += deltaTime;
                if (powerPelletFlashTimer >= POWER_PELLET_FLASH_INTERVAL) {
                    powerPelletFlashState = !powerPelletFlashState;
                    powerPelletFlashTimer = 0;
                }

                if (frightenedMode) {
                    frightenedTimer -= deltaTime;
                    if (frightenedTimer <= 0) {
                        frightenedMode = false;
                        ghosts.forEach(ghost => ghost.frightened = false);
                    }
                }
            }
            drawPacman();
            ghosts.forEach(drawGhost);

            animationFrameId = requestAnimationFrame(gameLoop); 
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            const { rows, cols } = getMazeDimensions();

            if (gameState === 'build_mode') {
                let moved = false;
                switch (e.key) {
                    case 'w':
                    case 'ArrowUp':
                        if (buildCursor.row > 0) { buildCursor.row--; moved = true; }
                        break;
                    case 's':
                    case 'ArrowDown':
                        if (buildCursor.row < rows - 1) { buildCursor.row++; moved = true; }
                        break;
                    case 'a':
                    case 'ArrowLeft':
                        if (buildCursor.col > 0) { buildCursor.col--; moved = true; }
                        break;
                    case 'd':
                    case 'ArrowRight':
                        if (buildCursor.col < cols - 1) { buildCursor.col++; moved = true; }
                        break;
                    case 'Shift':
                    case 'ShiftLeft': 
                        const currentRow = buildCursor.row;
                        const currentCol = buildCursor.col;
                        const currentTileValue = currentMaze[currentRow][currentCol];
                        
                        let currentIndex = BUILD_TILE_TYPES.indexOf(currentTileValue);
                        if (currentIndex === -1) { 
                            currentIndex = 0; 
                        } else {
                            currentIndex = (currentIndex + 1) % BUILD_TILE_TYPES.length;
                        }
                        const newTileValue = BUILD_TILE_TYPES[currentIndex];

                        if (newTileValue === 6) {
                            let oldPacmanRow = -1;
                            let oldPacmanCol = -1;
                            for (let r = 0; r < currentMaze.length; r++) {
                                for (let c = 0; c < currentMaze[r].length; c++) {
                                    if (currentMaze[r][c] === 6) {
                                        oldPacmanRow = r;
                                        oldPacmanCol = c;
                                        break;
                                    }
                                }
                                if (oldPacmanRow !== -1) break;
                            }

                            if (oldPacmanRow !== -1 && (oldPacmanRow !== currentRow || oldPacmanCol !== currentCol)) {
                                currentMaze[oldPacmanRow][oldPacmanCol] = 0; 
                            }
                        }

                        currentMaze[currentRow][currentCol] = newTileValue;

                        buildCursor.feedbackActive = true;
                        buildCursor.feedbackTimer = 0;

                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        drawMaze();
                        drawBuildCursor();
                        updateBuildModeCounters(); 
                        break;
                }
                if (moved) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawMaze();
                    drawBuildCursor();
                }
            } else if (gameState === 'playing' || gameState === 'ready_prompt') {
                switch (e.key) {
                    case 'ArrowUp':
                        pacman.nextDx = 0;
                        pacman.nextDy = -1;
                        break;
                    case 'ArrowDown':
                        pacman.nextDx = 0;
                        pacman.nextDy = 1;
                        break;
                    case 'ArrowLeft':
                        pacman.nextDx = -1;
                        pacman.nextDy = 0;
                        break;
                    case 'ArrowRight':
                        pacman.nextDx = 1;
                        pacman.nextDy = 0;
                        break;
                    case 'p': 
                    case 'P':
                        togglePause();
                        break;
                }
            }
        });

        window.onload = initGame;

        window.addEventListener('resize', () => {
            const { rows, cols } = getMazeDimensions();
            canvas.width = cols * TILE_SIZE;
            canvas.height = rows * TILE_SIZE;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            if (gameState === 'build_mode') {
                drawBuildCursor();
            } else {
                drawPacman();
                ghosts.forEach(drawGhost);
            }
        });

    </script>
</body>
</html>
